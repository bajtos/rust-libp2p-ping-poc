// Inspired by ping handler from libp2p
// https://github.com/libp2p/rust-libp2p/tree/239a62c7640681290c4b2737c6067cf49aba828b/protocols/ping

// Copyright 2019 Parity Technologies (UK) Ltd.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

// use futures::prelude::*;
use libp2p::core::{Multiaddr, PeerId, UpgradeError};
use libp2p::futures::future::BoxFuture;
use libp2p::futures::{io, AsyncReadExt, AsyncWriteExt, FutureExt, Stream};
use libp2p::futures::{AsyncRead, AsyncWrite, StreamExt};
use libp2p::multiaddr::Protocol;
use libp2p::swarm::derive_prelude::{ConnectionId, FromSwarm};
use libp2p::swarm::handler::{
    ConnectionEvent, DialUpgradeError, FullyNegotiatedInbound, FullyNegotiatedOutbound,
};
use rand::{distributions, thread_rng, Rng};
use std::error::Error;
use std::pin::Pin;
use std::task::{Context, Poll};
use std::time::Duration;
use void::Void;
// use std::io::Write;
// use std::path::PathBuf;

use async_trait::async_trait;
use libp2p::core::upgrade;
use libp2p::mplex;
use libp2p::noise;
use libp2p::ping;
use libp2p::swarm::{
    ConnectionHandler, ConnectionHandlerEvent, ConnectionHandlerUpgrErr, KeepAlive,
    NegotiatedSubstream, NetworkBehaviour, NetworkBehaviourAction, PollParameters,
    SubstreamProtocol, Swarm, SwarmEvent,
};
use libp2p::yamux;
use libp2p::Transport;
use libp2p::{identity, request_response};
use std::collections::{hash_map, HashMap, HashSet, VecDeque};
use tokio::sync::{mpsc, oneshot};
use tokio::time::{sleep, Instant, Sleep};
use tokio_stream::wrappers::ReceiverStream;

// Custom ping protocol implementation

pub const PROTOCOL_NAME: &[u8] = libp2p::ping::PROTOCOL_NAME;
const TIMEOUT: Duration = Duration::new(10, 0);

pub struct PingBehaviour {
    /// Queue of events to yield to the swarm.
    events: VecDeque<PingEvent>,
}

pub type PingResult = ping::Result;
pub type PingFailure = ping::Failure;
pub type PingSuccess = ping::Success;

/// Event generated by the `Ping` network behaviour.
#[derive(Debug)]
pub struct PingEvent {
    /// The peer ID of the remote.
    pub peer: PeerId,
    /// The result of an inbound or outbound ping.
    pub result: PingResult,
}

impl PingBehaviour {
    pub fn new() -> Self {
        PingBehaviour {
            events: VecDeque::new(),
        }
    }
}

impl NetworkBehaviour for PingBehaviour {
    type ConnectionHandler = PingHandler;
    type OutEvent = PingEvent;

    fn new_handler(&mut self) -> Self::ConnectionHandler {
        PingHandler::new()
    }

    fn on_connection_handler_event(&mut self, peer: PeerId, _: ConnectionId, result: PingResult) {
        self.events.push_front(PingEvent { peer, result })
    }

    fn poll(
        &mut self,
        _: &mut Context<'_>,
        _: &mut impl PollParameters,
    ) -> Poll<NetworkBehaviourAction<Self::OutEvent, PingHandler>> {
        if let Some(e) = self.events.pop_back() {
            let PingEvent { result, peer } = &e;

            match result {
                Ok(PingSuccess::Ping { .. }) => println!("Ping sent to {:?}", peer),
                Ok(PingSuccess::Pong) => println!("Ping received from {:?}", peer),
                _ => {}
            }

            Poll::Ready(NetworkBehaviourAction::GenerateEvent(e))
        } else {
            Poll::Pending
        }
    }

    fn on_swarm_event(
        &mut self,
        event: libp2p::swarm::behaviour::FromSwarm<Self::ConnectionHandler>,
    ) {
        match event {
            FromSwarm::ConnectionEstablished(_)
            | FromSwarm::ConnectionClosed(_)
            | FromSwarm::AddressChange(_)
            | FromSwarm::DialFailure(_)
            | FromSwarm::ListenFailure(_)
            | FromSwarm::NewListener(_)
            | FromSwarm::NewListenAddr(_)
            | FromSwarm::ExpiredListenAddr(_)
            | FromSwarm::ListenerError(_)
            | FromSwarm::ListenerClosed(_)
            | FromSwarm::NewExternalAddr(_)
            | FromSwarm::ExpiredExternalAddr(_) => {}
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum State {
    /// We are inactive because the other peer doesn't support ping.
    Inactive {
        /// Whether or not we've reported the missing support yet.
        ///
        /// This is used to avoid repeated events being emitted for a specific connection.
        reported: bool,
    },
    /// We are actively pinging the other peer.
    Active,
}

struct PingHandler {
    /// The timer used for the delay to the next ping as well as
    /// the ping timeout.
    timer: Pin<Box<Sleep>>,
    /// Outbound ping failures that are pending to be processed by `poll()`.
    pending_errors: VecDeque<PingFailure>,
    /// The outbound ping state.
    outbound: Option<OutboundState>,
    /// Tracks the state of our handler.
    state: State,
}

impl PingHandler {
    pub fn new() -> Self {
        PingHandler {
            timer: Box::pin(sleep(TIMEOUT)),
            pending_errors: VecDeque::with_capacity(2),
            outbound: None,
            state: State::Active,
        }
    }

    fn on_dial_upgrade_error(
        &mut self,
        DialUpgradeError { error, .. }: DialUpgradeError<
            <Self as ConnectionHandler>::OutboundOpenInfo,
            <Self as ConnectionHandler>::OutboundProtocol,
        >,
    ) {
        self.outbound = None; // Request a new substream on the next `poll`.

        let error = match error {
            ConnectionHandlerUpgrErr::Upgrade(UpgradeError::Select(
                upgrade::NegotiationError::Failed,
            )) => {
                debug_assert_eq!(self.state, State::Active);

                self.state = State::Inactive { reported: false };
                return;
            }
            // Note: This timeout only covers protocol negotiation.
            ConnectionHandlerUpgrErr::Timeout => PingFailure::Timeout,
            e => PingFailure::Other { error: Box::new(e) },
        };

        self.pending_errors.push_front(error);
    }

    fn reset_timer(&mut self) {
        self.timer.as_mut().reset(Instant::now() + TIMEOUT);
    }
}

impl ConnectionHandler for PingHandler {
    type InEvent = Void;
    type OutEvent = PingResult;
    type Error = PingFailure;
    type InboundProtocol = upgrade::DeniedUpgrade;
    type OutboundProtocol = upgrade::ReadyUpgrade<&'static [u8]>;
    type OutboundOpenInfo = ();
    type InboundOpenInfo = ();

    fn listen_protocol(&self) -> SubstreamProtocol<upgrade::DeniedUpgrade, ()> {
        SubstreamProtocol::new(upgrade::DeniedUpgrade, ())
    }

    fn connection_keep_alive(&self) -> KeepAlive {
        KeepAlive::Yes
    }

    fn on_behaviour_event(&mut self, _: Void) {
        // TODO
    }

    fn poll(
        &mut self,
        cx: &mut Context<'_>,
    ) -> Poll<
        ConnectionHandlerEvent<upgrade::ReadyUpgrade<&'static [u8]>, (), PingResult, Self::Error>,
    > {
        match self.state {
            State::Inactive { reported: true } => {
                return Poll::Pending; // nothing to do on this connection
            }
            State::Inactive { reported: false } => {
                self.state = State::Inactive { reported: true };
                return Poll::Ready(ConnectionHandlerEvent::Custom(Err(
                    PingFailure::Unsupported,
                )));
            }
            State::Active => {}
        }

        loop {
            // Check for outbound ping failures.
            if let Some(error) = self.pending_errors.pop_back() {
                println!("Ping failure: {:?}", error);
                return Poll::Ready(ConnectionHandlerEvent::Custom(Err(error)));
            }

            // Continue outbound pings.
            match self.outbound.take() {
                Some(OutboundState::Ping(mut ping)) => match ping.poll_unpin(cx) {
                    Poll::Pending => {
                        if self.timer.poll_unpin(cx).is_ready() {
                            self.pending_errors.push_front(PingFailure::Timeout);
                        } else {
                            self.outbound = Some(OutboundState::Ping(ping));
                            break;
                        }
                    }
                    Poll::Ready(Ok((stream, rtt))) => {
                        self.reset_timer();
                        self.outbound = Some(OutboundState::Idle(stream));
                        return Poll::Ready(ConnectionHandlerEvent::Custom(Ok(
                            PingSuccess::Ping { rtt },
                        )));
                    }
                    Poll::Ready(Err(e)) => {
                        self.pending_errors
                            .push_front(PingFailure::Other { error: Box::new(e) });
                    }
                },
                Some(OutboundState::Idle(stream)) => match self.timer.poll_unpin(cx) {
                    Poll::Pending => {
                        self.outbound = Some(OutboundState::Idle(stream));
                        break;
                    }
                    Poll::Ready(()) => {
                        self.reset_timer();
                        self.outbound = Some(OutboundState::Ping(send_ping(stream).boxed()));
                    }
                },
                Some(OutboundState::OpenStream) => {
                    self.outbound = Some(OutboundState::OpenStream);
                    break;
                }
                None => {
                    self.outbound = Some(OutboundState::OpenStream);
                    let protocol =
                        SubstreamProtocol::new(upgrade::ReadyUpgrade::new(PROTOCOL_NAME), ())
                            .with_timeout(TIMEOUT);
                    return Poll::Ready(ConnectionHandlerEvent::OutboundSubstreamRequest {
                        protocol,
                    });
                }
            }
        }

        Poll::Pending
    }

    fn on_connection_event(
        &mut self,
        event: ConnectionEvent<
            Self::InboundProtocol,
            Self::OutboundProtocol,
            Self::InboundOpenInfo,
            Self::OutboundOpenInfo,
        >,
    ) {
        match event {
            ConnectionEvent::FullyNegotiatedInbound(FullyNegotiatedInbound {
                protocol: stream,
                ..
            }) => {
                // this should never happen, right?
                unreachable!();
                // self.inbound = Some(recv_ping(stream).boxed());
            }
            ConnectionEvent::FullyNegotiatedOutbound(FullyNegotiatedOutbound {
                protocol: stream,
                ..
            }) => {
                self.reset_timer();
                self.outbound = Some(OutboundState::Ping(send_ping(stream).boxed()));
            }
            ConnectionEvent::DialUpgradeError(dial_upgrade_error) => {
                self.on_dial_upgrade_error(dial_upgrade_error)
            }
            ConnectionEvent::AddressChange(_) | ConnectionEvent::ListenUpgradeError(_) => {}
        }
    }
}

type PingFuture = BoxFuture<'static, Result<(NegotiatedSubstream, Duration), io::Error>>;

/// The current state w.r.t. outbound pings.
enum OutboundState {
    /// A new substream is being negotiated for the ping protocol.
    OpenStream,
    /// The substream is idle, waiting to send the next ping.
    Idle(NegotiatedSubstream),
    /// A ping is being sent and the response awaited.
    Ping(PingFuture),
}

// Sends a ping and waits for the pong.
// https://github.com/libp2p/rust-libp2p/blob/5b4eab7bafe6cba8fea6c806027ea680662b7cc6/protocols/ping/src/protocol.rs

const PING_SIZE: usize = 32;

pub async fn send_ping<S>(mut stream: S) -> io::Result<(S, Duration)>
where
    S: AsyncRead + AsyncWrite + Unpin,
{
    let payload: [u8; PING_SIZE] = thread_rng().sample(distributions::Standard);
    stream.write_all(&payload).await?;
    stream.flush().await?;
    let started = Instant::now();
    let mut recv_payload = [0u8; PING_SIZE];
    stream.read_exact(&mut recv_payload).await?;
    if recv_payload == payload {
        Ok((stream, started.elapsed()))
    } else {
        Err(io::Error::new(
            io::ErrorKind::InvalidData,
            "Ping payload mismatch",
        ))
    }
}
